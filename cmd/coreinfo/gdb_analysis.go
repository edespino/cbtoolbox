package coreinfo

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
)

// getPostgresPath constructs the postgres binary path using GPHOME environment variable
func getPostgresPath() (string, error) {
	gphome := os.Getenv("GPHOME")
	if gphome == "" {
		return "", fmt.Errorf("GPHOME environment variable is not set")
	}

	postgresPath := filepath.Join(gphome, "bin", "postgres")
	if _, err := os.Stat(postgresPath); os.IsNotExist(err) {
		return "", fmt.Errorf("postgres binary not found: please ensure GPHOME is set and points to a valid Apache Cloudberry installation. Current GPHOME=%s", os.Getenv("GPHOME"))
	}
	return postgresPath, nil
}

// RunGDBAnalysisWithSummary performs GDB analysis and includes a summary at the top of the output.
func RunGDBAnalysisWithSummary(coreFiles []string, fileInfos map[string]*FileInfo, customGDBFile string) error {
	postgresPath, err := getPostgresPath()
	if err != nil {
		return fmt.Errorf("failed to get postgres binary path: %v", err)
	}

	for _, coreFile := range coreFiles {
		var gdbFilePath string

		// Select GDB file
		if customGDBFile != "" {
			gdbFilePath = customGDBFile
		} else {
			// Use embedded basic commands file
			fileContent, err := gdbFiles.ReadFile("resources/gdb_commands_basic.txt")
			if err != nil {
				return fmt.Errorf("failed to read embedded GDB file: %v", err)
			}

			// Create a temporary file for the GDB commands
			tmpFile, err := os.CreateTemp("", "gdb_commands_basic_*.txt")
			if err != nil {
				return fmt.Errorf("failed to create temporary file: %v", err)
			}
			defer os.Remove(tmpFile.Name()) // Ensure cleanup

			if _, err := tmpFile.Write(fileContent); err != nil {
				return fmt.Errorf("failed to write to temporary file: %v", err)
			}
			if err := tmpFile.Close(); err != nil {
				return fmt.Errorf("failed to close temporary file: %v", err)
			}

			gdbFilePath = tmpFile.Name()
		}

		// Run GDB command
		gdbCmd := exec.Command("gdb", "-q", "-x", gdbFilePath, postgresPath, coreFile)
		output, err := gdbCmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("failed to run GDB on %s: %v", coreFile, err)
		}

		// Extract and print summary
		summary, err := extractCoreSummary(string(output), fileInfos[coreFile])

		if err != nil {
			return fmt.Errorf("failed to extract core summary for %s: %v", coreFile, err)
		}
		fmt.Println(summary)

		// Print the full GDB output after the summary
		fmt.Println("\n======================================================================")
		fmt.Println("=== Detailed GDB Output ===")
		fmt.Println("======================================================================\n")
		fmt.Println(string(output))
	}

	return nil
}

var (
 // 	binaryRegex    = regexp.MustCompile("Core was generated by `(.+): ")

	//binaryRegex    = regexp.MustCompile("Core was generated by `([^']+)\\'")
  binaryRegex    = regexp.MustCompile("Core was generated by `(.+): .+\\'")
	signalRegex    = regexp.MustCompile(`Program terminated with signal (\w+), (.+)`)
	faultAddrRegex = regexp.MustCompile(`si_addr = ([^,]+)`)
	threadIDRegex  = regexp.MustCompile(`Current thread is (\d+)`)
	argsRegex      = regexp.MustCompile("Core was generated by `.*: ([^']+)\\'")
)

func extractCoreSummary(gdbOutput string, fileInfo *FileInfo) (string, error) {
	var binary, signal, faultAddr, threadID, processArgs string

	// Match and extract relevant information
	if match := binaryRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		binary = match[1]
	} else {
		return "", fmt.Errorf("failed to extract binary information")
	}

	if match := signalRegex.FindStringSubmatch(gdbOutput); len(match) > 2 {
		signal = fmt.Sprintf("%s (%s)", match[1], match[2])
	} else {
		signal = "Unknown signal"
	}

	if match := faultAddrRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		faultAddr = match[1]
	} else {
		faultAddr = "N/A"
	}

	if match := threadIDRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		threadID = match[1]
	} else {
		threadID = "N/A"
	}

	if match := argsRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		processArgs = match[1]
	} else {
		processArgs = "N/A"
	}

	platform := "unknown"
	userInfo := "unknown"
	execPath := "unknown"
	if fileInfo != nil {
		platform = fileInfo.Platform
		userInfo = fmt.Sprintf("uid=%s(%s), gid=%s(%s)",
			fileInfo.RealUID, fileInfo.EffUID,
			fileInfo.RealGID, fileInfo.EffGID)
		execPath = fileInfo.ExecPath
	}

	// Format the summary
	summary := fmt.Sprintf(`
======================================================================
Apache Cloudberry Core Dump Analysis Summary
======================================================================

- Binary: %s
- Platform: %s
- User/Group: %s
- Binary Path: %s
- Signal: %s
- Faulting Address: %s
- Thread ID: %s
- Process Args: %s`,
		binary,
		platform,
		userInfo,
		execPath,
		signal,
		faultAddr,
		threadID,
		processArgs)

	return summary, nil
}
