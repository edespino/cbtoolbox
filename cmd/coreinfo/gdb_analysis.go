package coreinfo

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
)

// RunGDBAnalysisWithSummary performs GDB analysis and includes a summary at the top of the output.
func RunGDBAnalysisWithSummary(coreFiles []string, customGDBFile string) error {
	for _, coreFile := range coreFiles {
		var gdbFilePath string

		// Select GDB file
		if customGDBFile != "" {
			gdbFilePath = customGDBFile
		} else {
			// Use embedded basic commands file
			fileContent, err := gdbFiles.ReadFile("resources/gdb_commands_basic.txt")
			if err != nil {
				return fmt.Errorf("failed to read embedded GDB file: %v", err)
			}

			// Create a temporary file for the GDB commands
			tmpFile, err := os.CreateTemp("", "gdb_commands_basic_*.txt")
			if err != nil {
				return fmt.Errorf("failed to create temporary file: %v", err)
			}
			defer os.Remove(tmpFile.Name()) // Ensure cleanup

			if _, err := tmpFile.Write(fileContent); err != nil {
				return fmt.Errorf("failed to write to temporary file: %v", err)
			}
			if err := tmpFile.Close(); err != nil {
				return fmt.Errorf("failed to close temporary file: %v", err)
			}

			gdbFilePath = tmpFile.Name()
		}

		// Run GDB command
		gdbCmd := exec.Command("gdb", "-q", "-x", gdbFilePath, "/usr/local/cloudberry-db/bin/postgres", coreFile)
		output, err := gdbCmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("failed to run GDB on %s: %v", coreFile, err)
		}

		// Extract and print summary
		summary, err := extractCoreSummary(string(output))
		if err != nil {
			return fmt.Errorf("failed to extract core summary for %s: %v", coreFile, err)
		}
		fmt.Println(summary)

		// Print the full GDB output after the summary
		fmt.Println("Detailed GDB Output:")
		fmt.Println(string(output))
	}

	return nil
}

// RunGDBAnalysis uses the embedded GDB command files for analysis.
func RunGDBAnalysis(coreFiles []string, customGDBFile string) error {
	var gdbFilePath string

	if customGDBFile != "" {
		gdbFilePath = customGDBFile
	} else {
		// Extract the embedded basic GDB commands to a temporary file
		tmpFile, err := extractEmbeddedFile("gdb_commands_basic.txt")
		if err != nil {
			return fmt.Errorf("failed to extract embedded GDB commands: %v", err)
		}
		defer os.Remove(tmpFile)
		gdbFilePath = tmpFile
	}

	for _, coreFile := range coreFiles {
		gdbCmd := exec.Command("gdb", "-x", gdbFilePath, "/usr/local/cloudberry-db/bin/postgres", coreFile)
		gdbCmd.Stdout = os.Stdout
		gdbCmd.Stderr = os.Stderr

		if err := gdbCmd.Run(); err != nil {
			return fmt.Errorf("failed to run GDB on %s: %v", coreFile, err)
		}
	}

	return nil
}

func extractCoreSummary(gdbOutput string) (string, error) {
	var binary, signal, faultAddr, threadID, processArgs string

	binaryRegex := regexp.MustCompile("Core was generated by `([^']+)\\'")
	signalRegex := regexp.MustCompile(`Program terminated with signal (\w+), (.+)`)
	faultAddrRegex := regexp.MustCompile(`si_addr = ([^,]+)`)
	threadIDRegex := regexp.MustCompile(`Current thread is (\d+)`)
	argsRegex := regexp.MustCompile(`Core was generated by '([^']+)'.*`)

	// Match and extract relevant information
	if match := binaryRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		binary = match[1]
	} else {
		return "", fmt.Errorf("failed to extract binary information")
	}

	if match := signalRegex.FindStringSubmatch(gdbOutput); len(match) > 2 {
		signal = fmt.Sprintf("%s (%s)", match[1], match[2])
	} else {
		signal = "Unknown signal"
	}

	if match := faultAddrRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		faultAddr = match[1]
	} else {
		faultAddr = "N/A"
	}

	if match := threadIDRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		threadID = match[1]
	} else {
		threadID = "N/A"
	}

	if match := argsRegex.FindStringSubmatch(gdbOutput); len(match) > 1 {
		processArgs = match[1]
	} else {
		processArgs = "N/A"
	}

	// Format the summary
	summary := fmt.Sprintf(`
Core Dump Analysis Summary:
----------------------------------------
- Binary: %s
- Signal: %s
- Faulting Address: %s
- Thread ID: %s
- Process Args: %s
`, binary, signal, faultAddr, threadID, processArgs)

    return summary, nil
}
